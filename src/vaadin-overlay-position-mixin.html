<!--
@license
Copyright (c) 2019 Vaadin Ltd.
This program is available under Apache License Version 2.0, available at https://vaadin.com/license/
-->

<script>
  window.Vaadin = window.Vaadin || {};
  window.Vaadin.Overlay = window.Vaadin.Overlay || {};

  /**
   * @polymerMixin
   */
  Vaadin.Overlay.PositionMixin = superClass => class PositionMixin extends superClass {

    static get properties() {
      return {
        positionTarget: {
          type: Object,
          value: null
        },

        horizontalAlign: {
          type: String,
          value: 'start',
          reflectToAttribute: true
        },
        verticalAlign: {
          type: String,
          value: 'top',
          reflectToAttribute: true
        },

        horizontalOverlap: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        },
        verticalOverlap: {
          type: Boolean,
          value: false,
          reflectToAttribute: true
        }
      };
    }
    static get observers() {
      return [`_positionSettingsChanged(positionTarget, horizontalAlign, verticalAlign,
        horizontalOverlap, verticalOverlap)`];
    }

    connectedCallback() {
      super.connectedCallback();
      const boundUpdatePosition = this.updatePosition.bind(this);

      this.addEventListener('opened-changed', e => {
        const func = e.detail.value ? 'addEventListener' : 'removeEventListener';
        window[func]('scroll', boundUpdatePosition);
        window[func]('resize', boundUpdatePosition);
      });
    }

    _positionSettingsChanged() {
      setTimeout(() => this.updatePosition());
    }

    updatePosition() {
      if (!this.positionTarget) {
        return;
      }
      const targetRect = this.positionTarget.getBoundingClientRect();

      const rtl = getComputedStyle(this).direction === 'rtl';

      const horizontalPosition = this.__calculateHorizontalPosition(targetRect, rtl);
      const verticalPosition = this.__calculateVerticalPosition(targetRect);

      const props = Object.fromEntries([horizontalPosition, verticalPosition]);
      this.__doSetPosition(props, rtl);
    }

    __calculateHorizontalPosition(targetRect, rtl) {
      const propNames = {
        start: 'left',
        end: 'right'
      };
      const overlayWidth = this.clientWidth;
      const contentWidth = this.$.content.clientWidth;
      const viewportWidth = Math.min(window.innerWidth, document.documentElement.clientWidth);
      const defaultAlignLeft = (!rtl && this.horizontalAlign === 'start') || (rtl && this.horizontalAlign === 'end');
      const currentAlignLeft = !!this.style.left;
      return this.__calculatePositionInOneDimension(targetRect, overlayWidth, contentWidth,
        viewportWidth, defaultAlignLeft, currentAlignLeft, this.horizontalOverlap, propNames);
    }

    __calculateVerticalPosition(targetRect) {
      const propNames = {
        start: 'top',
        end: 'bottom'
      };
      const overlayHeight = this.clientHeight;
      const contentHeight = this.$.content.clientHeight;
      const viewportHeight = Math.min(window.innerHeight, document.documentElement.clientHeight);
      const defaultAlignTop = this.verticalAlign === 'top';
      const currentAlignTop = !!this.style.top;
      return this.__calculatePositionInOneDimension(targetRect, overlayHeight, contentHeight,
        viewportHeight, defaultAlignTop, currentAlignTop, this.verticalOverlap, propNames);
    }

    __calculatePositionInOneDimension(targetRect, overlaySize, contentSize, viewportSize, defaultAlignStart, currentAlignStart, overlap, propNames) {
      const spaceForStartAlignment = viewportSize - targetRect[overlap ? propNames.start : propNames.end];
      const spaceForEndAlignment = targetRect[overlap ? propNames.end : propNames.start];

      const spaceForDefaultAlignment = defaultAlignStart ? spaceForStartAlignment : spaceForEndAlignment;
      const spaceForOtherAlignment = defaultAlignStart ? spaceForEndAlignment : spaceForStartAlignment;

      const currentlyOnDefaultSide = currentAlignStart === defaultAlignStart;

      const shouldGoToDefaultSide = this.__shouldGoToDefaultSide(currentlyOnDefaultSide, overlaySize, contentSize, spaceForDefaultAlignment, spaceForOtherAlignment);

      const shouldAlignStart = (shouldGoToDefaultSide && defaultAlignStart) || (!shouldGoToDefaultSide && !defaultAlignStart);

      if (shouldAlignStart) {
        const cssPropName = propNames.start;
        const cssPropValue = targetRect[overlap ? propNames.start : propNames.end];
        return [cssPropName, cssPropValue];
      } else {
        const cssPropName = propNames.end;
        const cssPropValue = viewportSize - (targetRect[overlap ? propNames.end : propNames.start]);
        return [cssPropName, cssPropValue];
      }
    }

    __shouldGoToDefaultSide(currentlyOnDefaultSide, overlaySize, contentSize, spaceOnDefaultSide, spaceOnOtherSide) {
      if (spaceOnDefaultSide > spaceOnOtherSide) {
        return true;
      }
      const fitsOnCurrentSide = contentSize < overlaySize;
      if (currentlyOnDefaultSide) {
        return fitsOnCurrentSide;
      }
      if (!fitsOnCurrentSide) {
        return false;
      }
      return contentSize < spaceOnDefaultSide;
    }

    __doSetPosition(cssProps, rtl) {
      ['left', 'right', 'top', 'bottom'].forEach(propName => {
        if (cssProps[propName] !== undefined) {
          this.style[propName] = cssProps[propName] + 'px';
        } else {
          this.style[propName] = '';
        }
      });

      const alignStart = (!rtl && cssProps.left) || (rtl && cssProps.right);
      this.style.alignItems = alignStart ? 'flex-start' : 'flex-end';

      this.style.justifyContent = cssProps.top ? 'flex-start' : 'flex-end';
    }

  };
</script>
